Sources : Sources : 
Riel, A. J. (1996). Object-Oriented Design Heuristics. Addison-Wesley Professional.


I'm analyzing a Java class called StudentPortalHelper for cohesion using Arthur Riel's heuristics. The class has methods for GPA calculation, CSV export, email formatting, date formatting, payment processing, password checking, and caching. 

 could you explain what high vs low cohesion means in simple terms, and which of Riel's heuristics would be most relevant for evaluating this class?
Of course! Let's break this down in simple terms and then apply Riel's heuristics to your StudentPortalHelper class.

High vs. Low Cohesion in Simple Terms
Think of a class like a kitchen tool.

High Cohesion (Good): A chef's knife. It has one primary, focused job: to chop, slice, and dice. All its parts (the sharp blade, the sturdy handle) work together perfectly for that single, well-defined purpose. It's easy to understand, use, and maintain.

Low Cohesion (Bad): A "Swiss Army Knife" class. It has a blade, but it also has a corkscrew, a screwdriver, a can opener, and a toothpick. These functions are only loosely related ("things you might need on a camping trip"). It's harder to understand its primary purpose, and if the screwdriver breaks, you have to deal with the entire complex, clunky object.

In software terms:

High Cohesion means a class or module has a single, well-defined responsibility. All its parts are strongly related and work towards a single goal.

Low Cohesion means a class is trying to do too many different, unrelated things. It's a "jack of all trades, master of none."

Applying Riel's Heuristics to StudentPortalHelper
Arthur Riel's heuristics are a set of guidelines for evaluating Object-Oriented design. Your StudentPortalHelper is a classic example of what Riel would call a low-cohesion class, often referred to as a "God Class" or "Large Class" smell.

Here are the most relevant heuristics for your class:

1. Most Relevant: H-2 - The number of methods in a class (The "Singularity of Purpose" Heuristic)
"A class should only capture one key abstraction."

This is the most direct hit. Your StudentPortalHelper is not capturing one key abstraction; it's capturing at least seven:

Academic Logic (GPA calculation)

Data Export (CSV export)

Communication (Email formatting)

Utility (Date formatting)

Finance (Payment processing)

Security (Password checking)

Performance (Caching)

This is a clear violation. The class has no single, clear purpose.

2. Very Relevant: H-4 / H-5 - The number of "non-communicating" methods
"A class should not contain a set of methods that do not communicate with each other."

This is also a perfect description of your class. Let's see which methods likely communicate:

Does calculateGPA() call or share data with processPayment()? No.

Does formatEmail() have anything to do with checkPasswordStrength()? No.

Does the cacheData() method interact with exportToCSV()? Unlikely.

These methods are "strangers" to each other. They happen to be in the same class, but they don't work together. They are a random collection of utilities. This is a strong indicator of Low Cohesion.

3. Very Relevant: H-8 - The number of "helper" methods
"A class should not be a collection of helper functions."

The name of your class, StudentPortalHelper, is a giant red flag. The word "Helper" or "Manager" often indicates a dumping ground for methods that the designer didn't know where else to put. Riel explicitly calls this out as a sign of poor design. Your class is a textbook example of this anti-pattern.

Summary and Recommended Refactoring
Verdict: The StudentPortalHelper class has very low cohesion.

It violates the fundamental principle of the Single Responsibility Principle (SRP), which is a core concept that aligns perfectly with Riel's heuristics.

How to Fix It (Refactoring):

You should break this "Swiss Army Knife" class into several focused, high-cohesion classes. For example:

StudentAcademicService

calculateGPA()

DataExporter

exportToCSV()

NotificationService

formatEmail()

PaymentProcessor

processPayment()

SecurityUtils (could be a static utility class if it's stateless)

checkPasswordStrength()

CacheManager

cacheData(), getFromCache()

The formatDate() method might belong in a general DateUtils class, or if it's specific to student dates (e.g., semester deadlines), it could go in StudentAcademicService.

By doing this, each new class will have a single, clear reason to change, making your code easier to understand, test, and maintain.

